{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nclass TokenManager {\n  /**\r\n   *\r\n   * @param {Array} tokens\r\n   */\n  constructor(classes) {\n    this.classes = classes;\n  }\n  setTokensAndAnnotation(tokens, currentAnnotation) {\n    this.tokens = tokens.map(t => ({\n      type: \"token\",\n      start: t[0],\n      end: t[1],\n      text: t[2]\n    }));\n    this.words = tokens.map(t => t[2]);\n    if (currentAnnotation != undefined) {\n      // reset prevoius annotation state\n      for (let i = 0; i < currentAnnotation.entities.length; i++) {\n        var start = currentAnnotation.entities[i][0];\n        var end = currentAnnotation.entities[i][1];\n        var entityName = currentAnnotation.entities[i][2];\n        var entityClass = this.classes.find(c => c.name.toUpperCase() === entityName.toUpperCase());\n        if (!entityClass) {\n          entityClass = {\n            \"name\": entityName\n          };\n        }\n        this.addNewBlock(start, end, entityClass);\n      }\n    }\n  }\n\n  /**\r\n   * Creates a new token block with the tokens whose starts match the input\r\n   * parameters\r\n   *\r\n   * @param {Number} start 'start' value of the token forming the start of the token block\r\n   * @param {Number} end 'start' value of the token forming the end of the token block\r\n   * @param {Number} _class the id of the class to highlight\r\n   */\n  addNewBlock(_start, _end, _class) {\n    let selectedTokens = [];\n    let newTokens = [];\n    let selectionStart = _end < _start ? _end : _start;\n    let selectionEnd = _end > _start ? _end : _start;\n    for (let i = 0; i < this.tokens.length; i++) {\n      let currentToken = this.tokens[i];\n      if (currentToken.end < selectionStart) {\n        // token is before the selection\n        newTokens.push(currentToken);\n      } else if (currentToken.end > selectionStart && currentToken.start < selectionEnd) {\n        // token is inside the selection\n        if (currentToken.type == \"token-block\") {\n          if (currentToken.label.toUpperCase() == _class.name.toUpperCase()) {\n            // tokens are from the same class\n            selectedTokens.push(...currentToken.tokens);\n          } else {\n            // tokens are from different class\n            let tokensBeforeSelection = [];\n            let tokensAfterSelection = [];\n            let oldTokens = currentToken.tokens;\n            for (let j = 0; j < oldTokens.length; j++) {\n              let oldToken = oldTokens[j];\n              if (oldToken.end < selectionStart) {\n                tokensBeforeSelection.push(oldToken);\n              } else if (oldToken.end > selectionStart && oldToken.start < selectionEnd) {\n                selectedTokens.push(oldToken);\n              } else if (oldToken.start >= selectionEnd) {\n                tokensAfterSelection.push(oldToken);\n              }\n            }\n            if (tokensBeforeSelection.length) {\n              newTokens.push({\n                type: \"token-block\",\n                start: tokensBeforeSelection[0].start,\n                end: tokensBeforeSelection[tokensBeforeSelection.length - 1].end,\n                tokens: tokensBeforeSelection,\n                label: currentToken.label,\n                classId: currentToken.classId,\n                backgroundColor: currentToken.backgroundColor\n              });\n            }\n            if (selectedTokens.length && tokensAfterSelection.length) {\n              // there are selected tokens and more tokens in block after selection\n              newTokens.push({\n                type: \"token-block\",\n                start: selectedTokens[0].start,\n                end: selectedTokens[selectedTokens.length - 1].end,\n                tokens: selectedTokens,\n                label: _class && _class.name ? _class.name : \"Unlabelled\",\n                classId: _class && _class.id ? _class.id : 0,\n                backgroundColor: _class && _class.color ? _class.color : null\n              });\n              selectedTokens = [];\n            }\n            if (tokensAfterSelection.length) {\n              newTokens.push({\n                type: \"token-block\",\n                start: tokensAfterSelection[0].start,\n                end: tokensAfterSelection[tokensAfterSelection.length - 1].end,\n                tokens: tokensAfterSelection,\n                label: currentToken.label,\n                classId: currentToken.classId,\n                backgroundColor: currentToken.backgroundColor\n              });\n            }\n          }\n        } else if (currentToken.type == \"token\") {\n          selectedTokens.push(currentToken);\n        }\n      } else if (currentToken.start >= selectionEnd && selectedTokens.length) {\n        // token is first after the selection\n        newTokens.push({\n          type: \"token-block\",\n          start: selectedTokens[0].start,\n          end: selectedTokens[selectedTokens.length - 1].end,\n          tokens: selectedTokens,\n          label: _class && _class.name ? _class.name : \"Unlabelled\",\n          classId: _class && _class.id ? _class.id : 0,\n          backgroundColor: _class && _class.color ? _class.color : null\n        });\n        selectedTokens = [];\n        newTokens.push(currentToken);\n      } else {\n        newTokens.push(currentToken);\n      }\n    }\n\n    // Case if the selected tokens are at the end of the text and have not been added to the newTokens\n    if (selectedTokens.length) {\n      newTokens.push({\n        type: \"token-block\",\n        start: selectedTokens[0].start,\n        end: selectedTokens[selectedTokens.length - 1].end,\n        tokens: selectedTokens,\n        label: _class && _class.name ? _class.name : \"Unlabelled\",\n        classId: _class && _class.id ? _class.id : 0,\n        backgroundColor: _class && _class.color ? _class.color : null\n      });\n    }\n    this.tokens = newTokens;\n  }\n\n  /**\r\n   * Removes a token block and puts back all the tokens in their original position\r\n   *\r\n   * @param {Number} blockStart 'start' value of the token block to remove\r\n   */\n  removeBlock(blockStart) {\n    let newTokens = [];\n    for (let i = 0; i < this.tokens.length; i++) {\n      if (this.tokens[i].type === \"token-block\" && this.tokens[i].start === blockStart) {\n        newTokens.push(...this.tokens[i].tokens);\n      } else {\n        newTokens.push(this.tokens[i]);\n      }\n    }\n    this.tokens = newTokens;\n  }\n\n  /**\r\n   * Removes all the tag blocks and leaves only tokens\r\n   */\n  resetBlocks() {\n    let newTokens = [];\n    for (let i = 0; i < this.tokens.length; i++) {\n      if (this.tokens[i].type === \"token\") {\n        newTokens.push(this.tokens[i]);\n      } else {\n        newTokens.push(...this.tokens[i].tokens);\n      }\n    }\n    this.tokens = newTokens;\n  }\n\n  /**\r\n   * Exports the tokens and the token blocks as annotations\r\n   */\n  exportAsAnnotation() {\n    let entities = [];\n    for (let i = 0; i < this.tokens.length; i++) {\n      if (this.tokens[i].type === \"token-block\") {\n        let b = this.tokens[i];\n        entities.push([b.start, b.end, b.label]);\n      }\n    }\n    return entities;\n  }\n}\nexport default TokenManager;","map":{"version":3,"names":["TokenManager","constructor","classes","setTokensAndAnnotation","tokens","currentAnnotation","map","t","type","start","end","text","words","undefined","i","entities","length","entityName","entityClass","find","c","name","toUpperCase","addNewBlock","_start","_end","_class","selectedTokens","newTokens","selectionStart","selectionEnd","currentToken","push","label","tokensBeforeSelection","tokensAfterSelection","oldTokens","j","oldToken","classId","backgroundColor","id","color","removeBlock","blockStart","resetBlocks","exportAsAnnotation","b"],"sources":["C:/Users/Filip/GIT_PROJECTS/annotator_with_packages/src/components/token-manager.js"],"sourcesContent":["class TokenManager {\r\n  /**\r\n   *\r\n   * @param {Array} tokens\r\n   */\r\n  constructor(classes) {\r\n    this.classes = classes\r\n  }\r\n\r\n  setTokensAndAnnotation(tokens, currentAnnotation) {\r\n    this.tokens = tokens.map((t) => ({\r\n      type: \"token\",\r\n      start: t[0],\r\n      end: t[1],\r\n      text: t[2],\r\n    }));\r\n    this.words = tokens.map(t => t[2]);\r\n\r\n    if (currentAnnotation != undefined) {\r\n      // reset prevoius annotation state\r\n      for (let i = 0; i < currentAnnotation.entities.length; i++) {\r\n        var start = currentAnnotation.entities[i][0];\r\n        var end = currentAnnotation.entities[i][1];\r\n        var entityName = currentAnnotation.entities[i][2];\r\n        var entityClass = this.classes.find(c => c.name.toUpperCase() === entityName.toUpperCase())\r\n        if (!entityClass) {\r\n          entityClass = {\"name\": entityName};\r\n        }\r\n        this.addNewBlock(start, end, entityClass)\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates a new token block with the tokens whose starts match the input\r\n   * parameters\r\n   *\r\n   * @param {Number} start 'start' value of the token forming the start of the token block\r\n   * @param {Number} end 'start' value of the token forming the end of the token block\r\n   * @param {Number} _class the id of the class to highlight\r\n   */\r\n  addNewBlock(_start, _end, _class) {\r\n    let selectedTokens = [];\r\n    let newTokens = [];\r\n\r\n    let selectionStart = _end < _start ? _end : _start;\r\n    let selectionEnd = _end > _start ? _end : _start;\r\n    \r\n    for (let i = 0; i < this.tokens.length; i++) {\r\n      let currentToken = this.tokens[i];\r\n      if (currentToken.end < selectionStart) {\r\n        // token is before the selection\r\n        newTokens.push(currentToken);\r\n      } else if (currentToken.end > selectionStart && currentToken.start < selectionEnd) {\r\n        // token is inside the selection\r\n        if (currentToken.type == \"token-block\") {\r\n          if (currentToken.label.toUpperCase() == _class.name.toUpperCase()) {\r\n            // tokens are from the same class\r\n            selectedTokens.push(...currentToken.tokens);\r\n          } else {\r\n            // tokens are from different class\r\n            let tokensBeforeSelection = [];\r\n            let tokensAfterSelection = [];\r\n            let oldTokens = currentToken.tokens;\r\n            for (let j = 0; j < oldTokens.length; j++) {\r\n              let oldToken = oldTokens[j];\r\n              if (oldToken.end < selectionStart) {\r\n                tokensBeforeSelection.push(oldToken);\r\n              } else if (oldToken.end > selectionStart && oldToken.start < selectionEnd) {\r\n                selectedTokens.push(oldToken);\r\n              } else if (oldToken.start >= selectionEnd) {\r\n                tokensAfterSelection.push(oldToken);\r\n              }\r\n            }\r\n\r\n            if (tokensBeforeSelection.length) {\r\n              newTokens.push({\r\n                type: \"token-block\",\r\n                start: tokensBeforeSelection[0].start,\r\n                end: tokensBeforeSelection[tokensBeforeSelection.length - 1].end,\r\n                tokens: tokensBeforeSelection,\r\n                label: currentToken.label,\r\n                classId: currentToken.classId,\r\n                backgroundColor: currentToken.backgroundColor,\r\n              })\r\n            }\r\n\r\n            if (selectedTokens.length && tokensAfterSelection.length) {\r\n              // there are selected tokens and more tokens in block after selection\r\n              newTokens.push({\r\n                type: \"token-block\",\r\n                start: selectedTokens[0].start,\r\n                end: selectedTokens[selectedTokens.length - 1].end,\r\n                tokens: selectedTokens,\r\n                label: _class && _class.name ? _class.name : \"Unlabelled\",\r\n                classId: _class && _class.id ? _class.id : 0,\r\n                backgroundColor: _class && _class.color ? _class.color : null,\r\n              });\r\n              selectedTokens = [];\r\n            }\r\n\r\n            if (tokensAfterSelection.length) {\r\n              newTokens.push({\r\n                type: \"token-block\",\r\n                start: tokensAfterSelection[0].start,\r\n                end: tokensAfterSelection[tokensAfterSelection.length - 1].end,\r\n                tokens: tokensAfterSelection,\r\n                label: currentToken.label,\r\n                classId: currentToken.classId,\r\n                backgroundColor: currentToken.backgroundColor,\r\n              })\r\n            }\r\n          }\r\n        } else if (currentToken.type == \"token\") {\r\n          selectedTokens.push(currentToken);\r\n        }\r\n      } else if (currentToken.start >= selectionEnd && selectedTokens.length) {\r\n        // token is first after the selection\r\n        newTokens.push({\r\n          type: \"token-block\",\r\n          start: selectedTokens[0].start,\r\n          end: selectedTokens[selectedTokens.length - 1].end,\r\n          tokens: selectedTokens,\r\n          label: _class && _class.name ? _class.name : \"Unlabelled\",\r\n          classId: _class && _class.id ? _class.id : 0,\r\n          backgroundColor: _class && _class.color ? _class.color : null,\r\n        });\r\n        selectedTokens = [];\r\n        newTokens.push(currentToken);\r\n      } else {\r\n        newTokens.push(currentToken);\r\n      }\r\n    }\r\n\r\n    // Case if the selected tokens are at the end of the text and have not been added to the newTokens\r\n    if (selectedTokens.length) {\r\n      newTokens.push({\r\n        type: \"token-block\",\r\n        start: selectedTokens[0].start,\r\n        end: selectedTokens[selectedTokens.length - 1].end,\r\n        tokens: selectedTokens,\r\n        label: _class && _class.name ? _class.name : \"Unlabelled\",\r\n        classId: _class && _class.id ? _class.id : 0,\r\n        backgroundColor: _class && _class.color ? _class.color : null,\r\n      });\r\n    }\r\n\r\n    this.tokens = newTokens;\r\n  }\r\n\r\n  /**\r\n   * Removes a token block and puts back all the tokens in their original position\r\n   *\r\n   * @param {Number} blockStart 'start' value of the token block to remove\r\n   */\r\n  removeBlock(blockStart) {\r\n    let newTokens = [];\r\n    for (let i = 0; i < this.tokens.length; i++) {\r\n      if (\r\n        this.tokens[i].type === \"token-block\" &&\r\n        this.tokens[i].start === blockStart\r\n      ) {\r\n        newTokens.push(...this.tokens[i].tokens);\r\n      } else {\r\n        newTokens.push(this.tokens[i]);\r\n      }\r\n    }\r\n    this.tokens = newTokens;\r\n  }\r\n\r\n  /**\r\n   * Removes all the tag blocks and leaves only tokens\r\n   */\r\n  resetBlocks() {\r\n    let newTokens = [];\r\n    for (let i = 0; i < this.tokens.length; i++) {\r\n      if (this.tokens[i].type === \"token\") {\r\n        newTokens.push(this.tokens[i]);\r\n      } else {\r\n        newTokens.push(...this.tokens[i].tokens);\r\n      }\r\n    }\r\n    this.tokens = newTokens;\r\n  }\r\n\r\n  /**\r\n   * Exports the tokens and the token blocks as annotations\r\n   */\r\n  exportAsAnnotation() {\r\n    let entities = [];\r\n    for (let i = 0; i < this.tokens.length; i++) {\r\n      if (this.tokens[i].type === \"token-block\") {\r\n        let b = this.tokens[i];\r\n        entities.push([b.start, b.end, b.label]);\r\n      }\r\n    }\r\n    return entities;\r\n  }\r\n}\r\n\r\nexport default TokenManager;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}